#!/bin/bash

# aide pour les commandes bash et scripts: https://devhints.io/bash
# aide pour dictionnaire "associative array": https://fr.cyberaxe.org/articles/bash-associa>
# aide lecture fichier et vérif: https://fr.linux-console.net/?p=22916
# documentation pour sed et les expressions régulières: https://www.shellunix.com/regexp.ht>
# documentation pour awk: https://fr.linux-console.net/?p=20194


function chat-bot() {
  # vérification du nombre de paramètres passés en commandes
  if [[ $# -gt 2 ]]; then
    echo "chat-bot destinataire [pseudo]" >&2
    exit 1
  fi

  # récupération des paramètres
  username="$1"
  botname="${2:-"bot"}"   # Valeur par défaut pour le bot si non spécifiée
  programme="./chat $2 $1 --bot" 

  # lancer le programme parallèle a Alice bot dans ce script
  # Fonction pour créer une coproc (coprocessus) et exécuter le programme
  function create_coproc() {
    local programme="$1"
    coproc CHAT_PIPES { eval "$programme"; }
    # Vérifier si la coproc a bien démarré
    if [[ $? -ne 0 ]]; then
      echo "Erreur dans l'exécution de la commande coproc" >&2
      exit 1
    fi
  }


  create_coproc "$programme"
  stdout=${CHAT_PIPES[0]}
  stdin=${CHAT_PIPES[1]}


  # Création d'un dictionnaire (associative array) pour stocker les fonctions du chat-bot
  declare -A commands

  # Définition des fonctions associées aux commandes

  function qui_suis_je() {
    echo "Vous êtes $username" >&"${CHAT_PIPES[1]}"
  }


  function li_fichier() {
    # Le fichier est récupéré après le nettoyage de la commande
    file="$1"
    # purpose == read -->lancer une lecture classique de fichier
    # purpose == mot  --> rechercher dans liste-bot.txt
    purpose="$2"
    found=0

    if [[ -e "$file" && -r "$file" ]]; then
      if [[ "$purpose" == "read" ]]; then
        while IFS= read -r line; do
          echo "$line" >&"${CHAT_PIPES[1]}"
        done < "$file"
      else

         : ' 
          commande de base corrigée par l' IA pour pouvoir ajouter tout les mots suivant a res: 
          syntaxe:  awk -v (vérifier) si purpose(mon mot recherché) est dans les "colones" du fichier
          awk subdivise les fichiers en colones où " " n'est pas compris comme caractère
          '

         res=$(awk -v purpose="$purpose" '$1 == purpose {for(i=2; i<=NF; i++) printf "%s ", $i; print ""}' "$file")

         # si res est vide renvoie le code utf-8 du robot (trouvé par IA)
         if [[ -z $res ]]; then
           echo -e "\xF0\x9F\xA4\x96 ?">&"${CHAT_PIPES[1]}"
         else
           echo "$res" >&"${CHAT_PIPES[1]}"
         fi
      fi
    else
      echo "Le fichier $file n'existe pas." >&"${CHAT_PIPES[1]}"
    fi
  }


  function au_revoir() {
    echo "Chat terminé">&"${CHAT_PIPES[1]}"
    exit 0
  }


  function liste() {
    for file in *; do
      echo "$file ">&"${CHAT_PIPES[1]}"
    done
  }


  # Enregistrement des commandes dans le dictionnaire
  commands[liste]="liste"
  commands[qui suis-je]="qui_suis_je"
  commands[au revoir]="au_revoir"
  commands[li]="li_fichier"


  # Boucle de lecture principale pour lire les commandes tapées par l'utilisateur
  while read -r line <&"${CHAT_PIPES[0]}"; do
    user_command="$line"
    # Affichage == "Username: MESSAGE' --> cleaned_command enlève "Username:" pour ne conserver que MESSAGE
    cleaned_command=$(echo "$line" | sed 's/^[^:]*: //')

    # awk sépare la chaine de caractères en substrings efficacement étant donné que " " n 'est pas considéré caractère. Il s'en sert alors pour diviser la chaine 
    command=$(echo "$cleaned_command" | awk '{print $1}')
    file=$(echo "$cleaned_command" | awk '{print $2}')

    vérifie si la commande est li FICHIER
    if [[ "$command" == "li" ]]; then
      ${commands[$command]} "$file" "read"

    si "li" n'est pas la commande détéctée il recherche dans les clés du dict pour lancer la fonction associée
    elif [[ -n "${commands[$cleaned_command]}" ]]; then
      # Exécution de la commande associée
      ${commands[$cleaned_command]}

    else
      
      li_fichier "liste-bot.txt" "$cleaned_command"
    fi
  done
}
chat-bot "$@"
